namespace NormalToHeightMapConverter

module Meshing =
    open System
    open System.IO

    let generateMesh (heights: float[,]) =
        let w = Array2D.length1 heights
        let d = Array2D.length2 heights

        let hmap =
            Array2D.init w d (fun x z ->
                let h = heights.[x, z]
                if h < 0.5 then 0 else ceil h |> int)

        // Generate top quads using greedy meshing
        let visited = Array2D.create w d false
        let mutable topQuads = []

        for z = 0 to d - 1 do
            for x = 0 to w - 1 do
                if not visited.[x, z] then
                    let h = hmap.[x, z]

                    if h > 0 then
                        // Grow in +X direction
                        let mutable x2 = x + 1

                        while x2 < w && not visited.[x2, z] && hmap.[x2, z] = h do
                            x2 <- x2 + 1

                        // Grow in +Z direction
                        let mutable z2 = z + 1
                        let mutable validZ = true

                        while z2 < d && validZ do
                            for xx = x to x2 - 1 do
                                if visited.[xx, z2] || hmap.[xx, z2] <> h then
                                    validZ <- false

                            if validZ then
                                z2 <- z2 + 1

                        // Mark visited
                        for zz = z to z2 - 1 do
                            for xx = x to x2 - 1 do
                                visited.[xx, zz] <- true

                        topQuads <- (x, z, x2, z2, h) :: topQuads

        // Generate side faces
        let mutable sideFaces = [] // List of tuples (v0, v1, v2, v3)

        for z = 0 to d - 1 do
            for x = 0 to w - 1 do
                let h = hmap.[x, z]

                if h > 0 then
                    // East face (+X direction)
                    let hEast = if x + 1 < w then hmap.[x + 1, z] else 0

                    if h > hEast then
                        let yBot = float hEast
                        let yTop = float h
                        let v0 = (float (x + 1), yBot, float z)
                        let v1 = (float (x + 1), yBot, float (z + 1))
                        let v2 = (float (x + 1), yTop, float (z + 1))
                        let v3 = (float (x + 1), yTop, float z)
                        sideFaces <- (v0, v3, v2, v1) :: sideFaces // CCW order for +X normal

                    // West face (-X direction)
                    let hWest = if x - 1 >= 0 then hmap.[x - 1, z] else 0

                    if h > hWest then
                        let yBot = float hWest
                        let yTop = float h
                        let v0 = (float x, yBot, float z)
                        let v1 = (float x, yBot, float (z + 1))
                        let v2 = (float x, yTop, float (z + 1))
                        let v3 = (float x, yTop, float z)
                        sideFaces <- (v0, v1, v2, v3) :: sideFaces // CCW order for -X normal

                    // North face (+Z direction)
                    let hNorth = if z + 1 < d then hmap.[x, z + 1] else 0

                    if h > hNorth then
                        let yBot = float hNorth
                        let yTop = float h
                        let v0 = (float x, yBot, float (z + 1))
                        let v1 = (float (x + 1), yBot, float (z + 1))
                        let v2 = (float (x + 1), yTop, float (z + 1))
                        let v3 = (float x, yTop, float (z + 1))
                        sideFaces <- (v0, v1, v2, v3) :: sideFaces // CCW order for +Z normal

                    // South face (-Z direction)
                    let hSouth = if z - 1 >= 0 then hmap.[x, z - 1] else 0

                    if h > hSouth then
                        let yBot = float hSouth
                        let yTop = float h
                        let v0 = (float x, yBot, float z)
                        let v1 = (float (x + 1), yBot, float z)
                        let v2 = (float (x + 1), yTop, float z)
                        let v3 = (float x, yTop, float z)
                        sideFaces <- (v0, v3, v2, v1) :: sideFaces // CCW order for -Z normal

        (List.rev topQuads, List.rev sideFaces)

    let fst3 (a, _, _) = a
    let snd3 (_, b, _) = b
    let thd3 (_, _, c) = c

    let writeObj (filename: string) (topQuads, sideFaces) =
        use writer = new StreamWriter(filename)
        writer.WriteLine("# Generated by F# Greedy Mesher with side faces")
        writer.WriteLine()

        let mutable vertexIndex = 1

        // Write top faces
        for (x, z, x2, z2, h) in topQuads do
            let v0 = (float x, float h, float z)
            let v1 = (float x2, float h, float z)
            let v2 = (float x2, float h, float z2)
            let v3 = (float x, float h, float z2)

            writer.WriteLine $"v {fst3 v0} {snd3 v0} {thd3 v0}"
            writer.WriteLine $"v {fst3 v1} {snd3 v1} {thd3 v1}"
            writer.WriteLine $"v {fst3 v2} {snd3 v2} {thd3 v2}"
            writer.WriteLine $"v {fst3 v3} {snd3 v3} {thd3 v3}"

            let i = vertexIndex
            writer.WriteLine($"f {i} {i + 1} {i + 2}")
            writer.WriteLine($"f {i} {i + 2} {i + 3}")
            vertexIndex <- vertexIndex + 4

        // Write side faces
        for (v0, v1, v2, v3) in sideFaces do
            writer.WriteLine $"v {fst3 v0} {snd3 v0} {thd3 v0}"
            writer.WriteLine $"v {fst3 v1} {snd3 v1} {thd3 v1}"
            writer.WriteLine $"v {fst3 v2} {snd3 v2} {thd3 v2}"
            writer.WriteLine $"v {fst3 v3} {snd3 v3} {thd3 v3}"

            let i = vertexIndex
            writer.WriteLine($"f {i} {i + 1} {i + 2}")
            writer.WriteLine($"f {i} {i + 2} {i + 3}")
            vertexIndex <- vertexIndex + 4

        let topQuadsLen = Seq.length topQuads
        let sideFacesLen = Seq.length sideFaces


        let totalFaces = topQuadsLen * 2 + sideFacesLen * 2

        printfn
            $"OBJ written to {filename} with {topQuadsLen} top quads and {sideFacesLen} side quads ({totalFaces} total faces)"
